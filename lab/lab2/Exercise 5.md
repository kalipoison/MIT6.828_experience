# Exercise 5

`mem_init()`在调用后 填写缺失的代码`check_page()`。

您的代码现在应该通过`check_kern_pgdir()` 和`check_page_installed_pgdir()`检查。



答：

　剩下的工作就是要完善mem_init()函数，现在要完善的功能就是把关于操作系统的一些重要的地址范围映射到现在的新页目录项上kern_pgdir上。这里我们可以利用前面定义过的boot_map_region函数。

　　首先我们要映射的范围是把pages数组映射到线性地址UPAGES，大小为一个PTSIZE。

　　所以我们添加的代码是：

```
boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);
```

　　其中perm变量之所以设置为PTE_U，是因为这部分空间是kernel space和user space中的代码都能访问的，所以要设置PTE_U。

　　

　　然后映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：

　　　　* [KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。

　　　　* [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。

　　对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：

```
boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W)
```

　　最后映射整个操作系统内核，虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。

　　访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：

```
boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W);
```

**问题**

| 入口 | 基本虚拟地址 | 指向（逻辑上）：      |
| ---- | ------------ | --------------------- |
| 1023 | ?            | 前 4MB 物理内存的页表 |
| 1022 | ?            | ?                     |
| .    | ?            | ?                     |
| .    | ?            | ?                     |
| .    | ?            | ?                     |
| 2    | 0x00800000   | ?                     |
| 1    | 0x00400000   | ?                     |
| 0    | 0x00000000   | [见下一个问题]        |

```
2. 到目前为止页目录表中已经包含多少有效页目录项？他们都映射到哪里？

　　　　3BD号页目录项，指向的是kern_pgdir

　　　　3BC号页目录项，指向的是pages数组

　　　　3BF号页目录项，指向的是bootstack

　　　　3C0~3FF号页目录项，指向的是kernel

　　3. 如果我们把kernel和user environment放在一个相同的地址空间中。为什么用户程序不同读取，写入内核的内存空间？用什么机制保护内核的地址范围。

　　　　用户程序不能去随意修改内核中的代码，数据，否则可能会破坏内核，造成程序崩溃。

　　　　正常的操作系统通常采用两个部件来完成对内核地址的保护，一个是通过段机制来实现的，但是JOS中的分段功能并没有实现。二就是通过分页机制来实现，通过把页表项中的 Supervisor/User位置0，那么用户态的代码就不能访问内存中的这个页。

　　4. 这个操作系统的可以支持的最大数量的物理内存是多大？

　　     由于这个操作系统利用一个大小为4MB的空间UPAGES来存放所有的页的PageInfo结构体信息，每个结构体的大小为8B，所以一共可以存放512K个PageInfo结构体，所以一共可以出现512K个物理页，每个物理页大小为4KB，自然总的物理内存占2GB。

　　5. 如果现在的物理内存页达到最大个数，那么管理这些内存所需要的额外空间开销有多少？　　

　　　　这里不太明白，参考别的答案是，首先需要存放所有的PageInfo，需要4MB，需要存放页目录表，kern_pgdir，4KB，还需要存放当前的页表，大小为2MB。所以总的开销就是6MB + 4KB。

　　6. 回顾entry.S文件中，当分页机制开启时，寄存器EIP的值仍旧是一个小的值。在哪个位置代码才开始运行在高于KERNBASE的虚拟地址空间中的？当程序位于开启分页之后到运行在KERNBASE之上这之间的时候，EIP的值是小的值，怎么保证可以把这个值转换为真实物理地址的？

　　　 在entry.S文件中有一个指令 jmp *%eax，这个指令要完成跳转，就会重新设置EIP的值，把它设置为寄存器eax中的值，而这个值是大于KERNBASE的，所以就完成了EIP从小的值到大于KERNBASE的值的转换。

　　　 在entry_pgdir这个页表中，也把虚拟地址空间[0, 4MB)映射到物理地址空间[0, 4MB)上，所以当访问位于[0, 4MB)之间的虚拟地址时，可以把它们转换为物理地址。
```

#### Address Space Layout Alternatives

我们在 JOS 中使用的地址空间布局并不是唯一可能的。操作系统可能会将内核映射到低线性地址，而将线性地址空间的*上部*留给用户进程。但是，x86 内核通常不采用这种方法，因为 x86 的一种向后兼容模式（称为*虚拟 8086 模式*）在处理器中“硬连线”以使用线性地址空间的底部，因此不能如果内核映射在那里，则完全可以使用。

甚至可以设计内核，尽管要困难得多，但不必为自己保留处理器线性或虚拟地址空间的*任何*固定部分，而是有效地允许用户级进程不受限制地使用*整个*4GB虚拟地址空间 - 同时仍然完全保护内核免受这些进程的影响，并相互保护不同的进程！

